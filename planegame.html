<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8"/>
<title>Jeu Avion 3D</title>
<style>
  body { margin:0; overflow:hidden; background:#111; font-family: Arial; }
  #hud {
    position:absolute; top:10px; left:10px;
    color:#0ff; font-size:24px;
    background: rgba(0,0,0,0.3); padding:6px 10px; border-radius:6px;
  }
</style>
</head>
<body>
<div id="hud">Niveau: 1</div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";

// --- SCÃˆNE & CAMERA ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.z = 5;

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- LUMIÃˆRES ---
const dirLight = new THREE.DirectionalLight(0xffffff,1);
dirLight.position.set(5,5,5);
scene.add(dirLight);
scene.add(new THREE.AmbientLight(0.5));

// --- PLAYER (modÃ¨le 3D) ---
let playerPlane = new THREE.Group(); // placeholder avant chargement

const loader = new GLTFLoader();
loader.load(
  'models/Jet.glb', // remplace par le chemin de ton modÃ¨le
  function(gltf) {
    playerPlane = gltf.scene;
    playerPlane.scale.set(0.5,0.5,0.5);
    playerPlane.position.set(0,0,2);
    scene.add(playerPlane);
  },
  undefined,
  function(error){ console.error(error); }
);

// --- HUD ---
const hud = document.getElementById("hud");

// --- NIVEAUX ---
let level = 1;
const levelDuration = 15000; // 15 sec
let obstacleSpeed = 0.2;
let spawnRate = 800;
let levelTimer;

function nextLevel(){
  level++;
  obstacleSpeed += 0.05;
  spawnRate = Math.max(300, spawnRate-100);
  hud.innerText = "Niveau: " + level;
  clearInterval(spawnInterval);
  spawnInterval = setInterval(spawnObstacle, spawnRate);
  levelTimer = setTimeout(nextLevel, levelDuration);
}
levelTimer = setTimeout(nextLevel, levelDuration);

// --- OBSTACLES ---
const obstacles = [];
function spawnObstacle(){
  const geo = new THREE.BoxGeometry(0.6,0.6,0.6);
  const mat = new THREE.MeshStandardMaterial({color:0xff0000});
  const obs = new THREE.Mesh(geo, mat);
  obs.position.set((Math.random()-0.5)*6, (Math.random()-0.5)*4, -20);
  scene.add(obs);
  obstacles.push(obs);
}
let spawnInterval = setInterval(spawnObstacle, spawnRate);

// --- CONTRÃ”LES ---
const keys = {};
window.addEventListener("keydown", e => keys[e.key] = true);
window.addEventListener("keyup", e => keys[e.key] = false);

// --- COLLISION ---
function checkCollision(a,b){
  const aBox = new THREE.Box3().setFromObject(a);
  const bBox = new THREE.Box3().setFromObject(b);
  return aBox.intersectsBox(bBox);
}

// --- GAME LOOP ---
let gameOver = false;
function animate(){
  if(gameOver) return;

  // mouvements
  if(playerPlane){
    if(keys["ArrowLeft"])  playerPlane.position.x -= 0.1;
    if(keys["ArrowRight"]) playerPlane.position.x += 0.1;
    if(keys["ArrowUp"])    playerPlane.position.y += 0.1;
    if(keys["ArrowDown"])  playerPlane.position.y -= 0.1;

    // limite zone
    playerPlane.position.x = THREE.MathUtils.clamp(playerPlane.position.x,-3,3);
    playerPlane.position.y = THREE.MathUtils.clamp(playerPlane.position.y,-2,2);
  }

  // obstacles
  obstacles.forEach(obs=>{
    obs.position.z += obstacleSpeed;

    if(playerPlane && checkCollision(playerPlane, obs)){
      alert("ðŸ’¥ Game Over au niveau " + level);
      gameOver = true;
      clearTimeout(levelTimer);
    }

    if(obs.position.z > camera.position.z) scene.remove(obs);
  });

  renderer.render(scene,camera);
  requestAnimationFrame(animate);
}
animate();

// --- RESIZE ---
window.addEventListener("resize",()=>{
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
});
</script>
</body>
</html>
